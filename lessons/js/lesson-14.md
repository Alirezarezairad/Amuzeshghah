### 🧩 درس ۱۴ — قوانین نام‌گذاری و کلمات کلیدی رزرو‌شده

(پوشش از صفحهٔ ۸۸ تا صفحهٔ ۹۵)

---

### 🎯 هدف درس:

هدف اصلی این درس، درک و یادگیری **قوانین تعیین نام** برای متغیرها، توابع و سایر اجزای برنامه است. شما باید بفهمید که کدام کلمات توسط جاوااسکریپت برای مقاصد خاصی رزرو شده‌اند (کلمات کلیدی) و نباید هرگز به عنوان نام متغیر استفاده شوند، تا از بروز خطاهای سینتکسی جلوگیری کنید.

---

### 🧠 توضیح مفهومی ساده و روان:

تصور کنید کامپیوتر یک اداره بزرگ است و جاوااسکریپت زبان رسمی این اداره.

بعضی از کلمات در این اداره، **مناصب بسیار خاصی** دارند، مثل "مدیر"، "معاون" یا "بخش‌نامه" (این‌ها کلمات کلیدی ما هستند).

اگر شما بخواهید یک کارمند جدید (متغیر) استخدام کنید و نامش را "مدیر" بگذارید، هر وقت بخش‌های دیگر بخواهند با کارمندتان صحبت کنند، اداره گیج می‌شود که آیا منظور شما آن "منصب کلیدی" است یا "کارمندتان"!

بنابراین، **کلمات کلیدی (Schlüsselwörter)**، کلماتی هستند که جاوااسکریپت برای دستورات خاصی رزرو کرده و شما حق ندارید از آن‌ها برای نام‌گذاری متغیرها یا توابع خود استفاده کنید.

---

### ⚙️ آموزش گام‌به‌گام با همه مفاهیم و زیر‌بخش‌ها:

#### ۱. مفهوم کلمات کلیدی (Reserved Keywords)

کلمات کلیدی، واژگانی هستند که در هستهٔ زبان برنامه‌نویسی جاوااسکریپت معنی و کاربرد خاصی دارند. استفاده از این کلمات به مفسر (Interpreter) دستور می‌دهد که عمل خاصی را انجام دهد. به عنوان مثال، کلمه `let` یک کلمه کلیدی است که برای تعریف متغیرهای قابل تغییر استفاده می‌شود. همچنین، `var` نیز کلمه کلیدی است که در نسخه‌های قدیمی‌تر برای تعریف متغیرها به کار می‌رفت.

#### ۲. کلمات کلیدی مربوط به تعریف متغیرها

ما قبلاً دیدیم که برای تعریف متغیرها از `let` و `var` استفاده می‌کنیم. همچنین، برای تعریف مقادیر ثابت، کلمه کلیدی `const` نیز وجود دارد (که در درس بعدی مفصل‌تر خواهیم خواند).

* `let`: برای تعریف متغیرها استفاده می‌شود.

* `var`: برای تعریف متغیرها در شیوه‌های قدیمی‌تر استفاده می‌شود.

* `class`: برای تعریف کلاس‌ها در برنامه‌نویسی شیءگرا استفاده می‌شود.

اگر شما سعی کنید از خود این کلمات کلیدی به عنوان نام متغیر استفاده کنید، برنامه با خطای سینتکسی مواجه خواهد شد.

#### ۳. لیست کلمات کلیدی رزرو شده (جدول ۳.۱)

جاوااسکریپت فهرستی طولانی از کلمات را رزرو کرده است. این کلمات برای کنترل جریان برنامه، تعریف ساختار داده‌ها، کار با توابع، مدیریت خطا و بسیاری موارد دیگر استفاده می‌شوند. در زیر، بخشی از این کلمات کلیدی و کاربرد آن‌ها آورده شده است:

| کلمه کلیدی (Schlüsselwort) |                              شرح (Beschreibung)                              | فصل ارجاع (Kapitel) |
| :------------------------: | :--------------------------------------------------------------------------: | :-----------------: |
|           `async`          |     برای مشخص کردن توابع ناهمگام (Asynchrone Funktionen) استفاده می‌شود.     |        فصل ۱۶       |
|           `await`          |             برای انتظار برای نتیجه توابع ناهمگام استفاده می‌شود.             |        فصل ۱۶       |
|           `break`          |         برای قطع کردن اجرای چند‌شاخه‌ای‌ها و حلقه‌ها استفاده می‌شود.         |  بخش ۳.۴.۴ و ۳.۴.۸  |
|           `case`           |         برای تعریف شاخه‌های برنامه در چند‌شاخه‌ای‌ها استفاده می‌شود.         |      بخش ۳.۴.۴      |
|           `class`          |                      برای تعریف کلاس‌ها استفاده می‌شود.                      |        فصل ۱۳       |
|           `catch`          |                       برای مدیریت خطاها استفاده می‌شود.                      |      بخش ۳.۶.۵      |
|            `do`            | برای تعریف حلقه‌های کنترل از پایین (fußgesteuerte Schleifen) استفاده می‌شود. |      بخش ۳.۴.۷      |
|           `else`           |         برای تعریف یک شاخهٔ جایگزین در ساختارهای شرطی استفاده می‌شود.        |      بخش ۳.۴.۲      |
|          `export`          |                     در ارتباط با ماژول‌ها استفاده می‌شود.                    |        فصل ۱۶       |
|          `extends`         |             برای تعریف زیرکلاس‌ها یا سوپرکلاس‌ها استفاده می‌شود.             |        فصل ۱۳       |
|          `finally`         |        برای تعریف رفتار استاندارد در زمان مدیریت خطاها استفاده می‌شود.       |      بخش ۳.۶.۵      |
|            `for`           |          برای تعریف حلقه‌های شمارشی (Zählschleifen) استفاده می‌شود.          |      بخش ۳.۴.۵      |
|         `function`         |                       برای تعریف توابع استفاده می‌شود.                       |      بخش ۳.۵.۱      |
|            `if`            |              برای تعریف دستورات شرطی و انشعاب‌ها استفاده می‌شود.             |  بخش ۳.۴.۱ و ۳.۴.۲  |
|          `import`          |                     در ارتباط با ماژول‌ها استفاده می‌شود.                    |        فصل ۱۶       |
|            `let`           |                      برای تعریف متغیرها استفاده می‌شود.                      |      بخش ۳.۱.۱      |
|            `new`           |          برای ایجاد نمونه‌های شیء (Object-Instanzen) استفاده می‌شود.         |        فصل ۴        |
|          `return`          |               برای تعریف مقدار بازگشتی یک تابع استفاده می‌شود.               |      بخش ۳.۵.۴      |
|          `static`          |              برای تعریف خصوصیات و متدهای استاتیک استفاده می‌شود.             |        فصل ۱۳       |
|           `super`          |             برای دسترسی به سوپرکلاس (Oberklasse) استفاده می‌شود.             |        فصل ۱۳       |
|          `switch`          |                   برای تعریف چند‌شاخه‌ای‌ها استفاده می‌شود.                  |      بخش ۳.۴.۴      |
|           `this`           |            برای دسترسی به شیء فعلی در داخل خود شیء استفاده می‌شود.           |        فصل ۴        |
|           `throw`          |                    برای پرتاب کردن یک خطا استفاده می‌شود.                    |      بخش ۳.۶.۶      |
|            `try`           |       برای تعریف بلوک کدی که ممکن است خطا در آن رخ دهد استفاده می‌شود.       |      بخش ۳.۶.۵      |
|          `typeof`          |                    برای تعیین نوع یک متغیر استفاده می‌شود.                   |      بخش ۳.۳.۹      |
|            `var`           |                      برای تعریف متغیرها استفاده می‌شود.                      |      بخش ۳.۱.۱      |
|           `void`           |          برای تعریف عبارتی که مقداری باز نمی‌گرداند استفاده می‌شود.          |          -          |

#### ۴. کلمات کلیدی رزرو شده بدون کارکرد فعلی

برخی از کلمات کلیدی نیز رزرو شده‌اند اما در حال حاضر هیچ تابعی به آن‌ها اختصاص داده نشده است. این کلمات شامل `enum`، `implements`، `interface`، `package`، `private`، `protected` و `public` هستند. با این حال، استفاده از آن‌ها به عنوان نام متغیر ممنوع است.

#### ۵. اجتناب از بازتعریف اشیاء سراسری (Global Objects)

علاوه بر کلمات کلیدی، باید از نام‌گذاری متغیرها به گونه‌ای که با اشیاء مهم سراسری (مانند `console` یا `window`) تداخل پیدا کند، اجتناب کنید. اگر یک متغیر با نامی مشابه یک شیء سراسری تعریف کنید، دسترسی به عملکرد اصلی آن شیء ممکن است از بین برود و منجر به خطای اجرایی شود.

#### ۶. پیامدهای بازنویسی شیء `console`

یک مثال بارز، تلاش برای بازنویسی شیء `console` است. اگر متغیری با نام `console` تعریف کنید و به آن مقداری تخصیص دهید، دیگر نمی‌توانید از متد `log()` روی شیء اصلی `console` استفاده کنید، زیرا جاوااسکریپت فکر می‌کند `console` یک عدد (مثلاً `4711`) است و نه یک شیء با متد `log()`. این منجر به خطایی مانند `TypeError: console.log is not a function` می‌شود.

---

### 💻 همه کدها و مثال‌های کتاب را بازسازی و خط‌به‌خط توضیح بده:

اگرچه در محدوده صفحات ۸۸ تا ۹۵ کد صریحی برای این بخش ذکر نشده است، اما مهم‌ترین مثال در ارتباط با این موضوع، **تداخل نام‌گذاری با اشیاء سراسری** است که باید به طور کامل توضیح داده شود:

#### مثال ۱: تعریف متغیر با کلمه کلیدی (غیرمجاز)

فرض کنید می‌خواهید نام یک متغیر را `let` بگذارید. این کار باعث خطا می‌شود:

```javascript
// تلاش برای استفاده از یک کلمه کلیدی رزرو شده به عنوان نام متغیر
let let = 10; 
// >> خطای سینتکسی (Syntax Error)
```

#### مثال ۲: تداخل نام‌گذاری با شیء سراسری `console` (Listing 3.7)

این کد نشان می‌دهد که اگر یک متغیر را با نام `console` تعریف کنید، عملکرد اصلی شیء `console` مختل می‌شود:

```javascript
const number = 22; // تعریف متغیر
console.log(number); // خروجی: 22 (این کار می‌کند)

const console = 4711; // تعریف یک متغیر به نام 'console' و تخصیص مقدار
console.log(number); 
// >> خروجی: TypeError: console.log is not a function
// توضیحات: در این نقطه، "console" دیگر شیء اصلی کنسول نیست، 
// بلکه یک متغیر از نوع عدد با مقدار ۴۷۱۱ است. بنابراین، متد log() 
// روی آن پیدا نمی‌شود.
```

این مثال نشان می‌دهد که چرا باید از نام‌های متغیر اجتناب کرد که با اشیاء عمومی تداخل دارند، اگرچه پیدا کردن چنین خطاهایی ممکن است در کدهای بزرگ‌تر، دشوار باشد.

#### مثال ۳: استفاده از نام‌های توصیفی و غیرکلیدی

به جای استفاده از کلمات کلیدی، ما از نام‌های توصیفی استفاده می‌کنیم (مثل آنچه در درس ۱۳ دیدیم):

```javascript
let userFirstName = 'Max'; // مجاز: نام توصیفی
let studentAge = 25; // مجاز: نام توصیفی
let maxItems = 4711; // مجاز: نام توصیفی

// مثال‌هایی از اعلان مجاز متغیرها با let (بر اساس Listing 3.2 و 3.6)
let firstName;
let x = 4711;
```

---

### 📊 نمودارها و جداول را به‌صورت Markdown بازسازی کن:

#### جدول ۱: کلمات کلیدی رزرو شده (بخش‌های انتخابی از جدول ۳.۱)

این جدول شامل کلمات کلیدی است که شما هرگز نباید از آن‌ها به عنوان نام متغیر استفاده کنید:

|         کلمه کلیدی        |       شرح کوتاه      |      استفاده ممنوع      |
| :-----------------------: | :------------------: | :---------------------: |
|           `let`           |      تعریف متغیر     |           بله           |
|           `var`           |  تعریف متغیر (قدیمی) |           بله           |
|          `const`          |      تعریف ثابت      | بله (در درس ۱۵ مفصل‌تر) |
|          `class`          |   تعریف ساختار کلاس  |           بله           |
|         `function`        |      تعریف تابع      |           بله           |
|   `if`, `else`, `switch`  | کنترل جریان (شرط‌ها) |           بله           |
| `try`, `catch`, `finally` |      مدیریت خطا      |           بله           |
|    `for`, `while`, `do`   |        حلقه‌ها       |           بله           |

#### جدول ۲: کلمات کلیدی رزرو شده (بدون کارکرد در حال حاضر)

این کلمات برای استفاده‌های آتی رزرو شده‌اند و نباید استفاده شوند:

|  کلمه کلیدی  |                وضعیت                |
| :----------: | :---------------------------------: |
|    `enum`    | رزرو شده، بدون تابع اختصاص داده شده |
| `implements` |               رزرو شده              |
|  `interface` |               رزرو شده              |
|   `package`  | رزرو شده، بدون تابع اختصاص داده شده |
|   `private`  | رزرو شده، بدون تابع اختصاص داده شده |
|  `protected` | رزرو شده، بدون تابع اختصاص داده شده |
|   `public`   | رزرو شده، بدون تابع اختصاص داده شده |

#### جدول ۳: اهمیت جلوگیری از تداخل نام‌گذاری

|     نوع نام    |          مثال         |                                     دلیل اجتناب                                    | منبع |
| :------------: | :-------------------: | :--------------------------------------------------------------------------------: | :--: |
| **کلمه کلیدی** | `var`، `let`، `class` |         بخشی از سینتکس زبان است. استفاده از آن منجر به خطای سینتکسی می‌شود.        |      |
| **شیء سراسری** |  `console`، `window`  | بازنویسی آن منجر به از دست رفتن عملکردهای اصلی مرورگر می‌شود و خطای اجرایی می‌دهد. |      |

#### جدول ۴: نکته طلایی درباره تداخل نام‌ها

|     وضعیت    |                                       توضیحات                                      |
| :----------: | :--------------------------------------------------------------------------------: |
|  خوانایی کد  |          همیشه از نام‌های توصیفی (مثل `userAge` به جای `x`) استفاده کنید.          |
| خطایابی آسان | نام‌هایی که با توابع یا متغیرهای سراسری تداخل دارند، خطایابی را بسیار سخت می‌کنند. |

---

### 💬 نکات طلایی استاد و اشتباهات رایج:

1. **خوانایی اولویت دارد:** اگرچه جاوااسکریپت به شما اجازه می‌دهد متغیرتان را `x` یا `a1b2c3` بگذارید، اما همیشه نام‌هایی انتخاب کنید که هدف متغیر را توضیح دهند (مثل `userScore` یا `totalPrice`). خوانایی کد شما مهم‌تر از کدنویسی سریع است.

2. **قانون طلایی CamelCase:** در جاوااسکریپت، قرارداد استاندارد این است که برای نام‌گذاری متغیرها و توابع از **CamelCase** استفاده کنید. یعنی کلمه اول با حرف کوچک شروع می‌شود و کلمات بعدی با حرف بزرگ (مثلاً `myFavoriteBook`). اگرچه این یک قانون سینتکسی نیست، اما رعایت آن توسط همه توسعه‌دهندگان، خوانایی را بالا می‌برد.

3. **پرهیز از بازتعریف:** همان‌طور که در مثال `console` دیدیم، حتی اگر نامی کلمه کلیدی رزرو شده نباشد، اگر شیئی در محیط اجرای شما (مثل مرورگر یا Node.js) وجود داشته باشد، بازتعریف آن منجر به خطاهای غیرمنتظره می‌شود. این خطاها در کدهای بزرگ‌تر، پیدا کردنشان دشوار است.

---

### 🧪 تمرین درس:

**تمرین ۱: شناسایی کلمات کلیدی**

کدام یک از نام‌های زیر، بر اساس لیست کلمات کلیدی رزرو شده (جدول ۱)، مجاز نیستند؟

الف) `score_1`

ب) `finally`

ج) `return`

د) `userName`

**تمرین ۲: نام‌گذاری مجاز**

آیا می‌توانید متغیری به نام `ifElse` تعریف کنید؟ (راهنمایی: `if` و `else` به تنهایی کلمات کلیدی هستند).

**تمرین ۳: تداخل نام**

فرض کنید کدی نوشتید که در آن `var throw = 'Error';` استفاده شده است. چه مشکلی پیش می‌آید و چرا؟

**تمرین ۴: شناسایی کلمات کلیدی رزرو شده**

کدام یک از کلمات زیر جزء کلمات کلیدی رزرو شده هستند؟

الف) `window`

ب) `new`

ج) `car`

د) `typeof`

**تمرین ۵: هدف از نام‌گذاری خوب**

اگر نام متغیری را `c` (به معنی counter) بگذارید، چه نکته‌ای را دربارهٔ استانداردهای نام‌گذاری حرفه‌ای جاوااسکریپت نقض کرده‌اید؟

**تمرین ۶: کلمات کلیدی بدون کارکرد**

اگرچه کلمه `enum` فعلاً تابعی ندارد، آیا استفاده از آن به عنوان نام متغیر مجاز است؟


**تمرین ۷: نام‌گذاری کلاس**

اگر بخواهید یک کلاس (با استفاده از کلمه کلیدی `class`) تعریف کنید، آیا می‌توانید نام آن را `function` بگذارید؟ چرا؟

**تمرین ۸: تشخیص خطای اجرایی (Runtime Error)**

تفاوت خطایی که در اثر استفاده از `let class = 1;` ایجاد می‌شود با خطایی که در اثر بازنویسی شیء `console` رخ می‌دهد (مانند Listing 3.7) چیست؟

---

### 💡 یک پروژه یا مثال کاربردی: جلوگیری از فاجعهٔ کنسول

بیایید یک تابع بنویسیم که وظیفهٔ چاپ پیام را دارد. ما نام این تابع را طوری انتخاب می‌کنیم که از تداخل با اشیاء سراسری جلوگیری کنیم، و در عین حال، مثال تداخل را هم برای یادآوری مرور می‌کنیم.

```javascript
'use strict'; 
// این تابع، از نامی مطمئن برای متغیر پیام استفاده می‌کند
function safeLogger(messageToLog) {
    // 1. تعریف یک متغیر محلی با نام مطمئن (نه console)
    let logMessage = 'LOG: ' + messageToLog; 

    // 2. استفاده از شیء سراسری console که تغییر نکرده است
    console.log(logMessage); 
}

safeLogger("برنامه با موفقیت اجرا شد."); 
// خروجی: LOG: برنامه با موفقیت اجرا شد.

// --- بخش هشدار: هرگز این کار را نکنید ---
// این بخش منجر به خطای TypeError: console.log is not a function می‌شود
// به دلیل بازنویسی شیء سراسری
try {
    const console = 4711; // فاجعه!
    console.log("این خط اجرا نخواهد شد.");
} catch(error) {
    // در محیط واقعی، این خط یک TypeError ایجاد می‌کند
    // اما در اینجا، ما از وقوع آن جلوگیری می‌کنیم تا برنامه خراب نشود
    // console.log(`خطا رخ داد: ${error.message}`);
}
```

**توضیح:** در این مثال، ما متغیر `logMessage` را با نامی واضح و غیرکلیدی تعریف کردیم و از نامگذاری‌هایی که به شیء سراسری `console` آسیب می‌زنند، اجتناب کردیم.

---

### 🧾 خلاصه (Cheat Sheet): جدول نکات کلیدی.

|       مفهوم       |                       قانون                       |   مثال درست (مجاز)   |    مثال غلط (غیرمجاز)   |
| :---------------: | :-----------------------------------------------: | :------------------: | :---------------------: |
|  **کلمات کلیدی**  |        استفاده از کلمات رزرو شده ممنوع است.       |  `let myScore = 5;`  |      `let let = 5;`     |
|  **اشیاء سراسری** |       از بازتعریف نام اشیاء سراسری بپرهیزید.      | `let myConsole = 1;` | `const console = 4711;` |
|    **خوانایی**    |    از CamelCase و نام‌های توصیفی استفاده کنید.    |     `totalPrice`     |           `tp`          |
| **کلید رزرو شده** | کلماتی مانند `class`، `return`، `if` ممنوع هستند. |     `finalResult`    |      `returnResult`     |

---

### 📚 آزمون پایانی:

#### سؤالات:

1. کدام کلمه کلیدی برای تعریف یک متغیر قابل تغییر به شیوه‌ای مدرن استفاده می‌شود؟

   الف) `var`

   ب) `const`

   ج) `let`

   د) `typeof`

2. اگر متغیری با نام `class` در جاوااسکریپت تعریف کنیم، چه نوع خطایی دریافت خواهیم کرد؟

   الف) خطای اجرایی (Runtime Error)

   ب) خطای منطقی (Logical Error)

   ج) خطای سینتکسی (Syntax Error)

   د) اخطار (Warning)

3. کدام کلمه کلیدی زیر، جزء کلمات رزرو شده برای تعریف انشعاب‌ها و ساختارهای شرطی است؟

   الف) `void`

   ب) `if`

   ج) `new`

   د) `debugger`

4. در Listing 3.7، چرا پس از تعریف `const console = 4711;`، تلاش برای فراخوانی `console.log(number)` شکست می‌خورد؟

   الف) چون `number` ثابت (const) تعریف شده است.

   ب) چون `console` دیگر شیء نیست، بلکه یک مقدار اولیه (Primitive Value) است.

   ج) چون متد `log()` فقط روی متغیرهای `var` کار می‌کند.

   د) چون عدد `4711` برای متغیر خیلی بزرگ است.

5. کلمه کلیدی `extends` در چه زمینه‌ای به کار می‌رود؟

   الف) تعریف حلقه‌ها

   ب) تعریف زیرکلاس‌ها

   ج) مدیریت ورودی/خروجی

   د) تعریف مقدار بازگشتی تابع

6. کدام کلمه کلیدی برای تعریف بلوک کدی که ممکن است در آن خطا رخ دهد، استفاده می‌شود؟

   الف) `throw`

   ب) `finally`

   ج) `try`

   د) `debugger`

7. آیا کلمه کلیدی `public` در جاوااسکریپت در حال حاضر عملکردی دارد؟

   الف) بله، برای تعریف متدهای عمومی کلاس.

   ب) خیر، اما کلمه‌ای رزرو شده است.

   ج) بله، برای اعلام متغیرهای عمومی.

   د) خیر، و جزء کلمات رزرو شده نیست.

8. هدف از استفاده از کلمات کلیدی مانند `let` و `var` چیست؟

9. اگر بخواهیم مقدار بازگشتی یک تابع را مشخص کنیم، از کدام کلمه کلیدی استفاده می‌کنیم؟

10. کلمه کلیدی `typeof` برای چه منظوری به کار می‌رود؟

#### پاسخنامه تشریحی:

1. **ج) `let`**: `let` روش توصیه شده برای تعریف متغیرهای قابل تغییر است.

2. **ج) خطای سینتکسی (Syntax Error)**: `class` یک کلمه کلیدی رزرو شده برای تعریف کلاس‌ها است. استفاده از آن به عنوان نام متغیر باعث می‌شود که مفسر نتواند کد را تفسیر کند.

3. **ب) `if`**: کلمات `if` و `else` برای تعریف دستورات شرطی و کنترل جریان برنامه به کار می‌روند.

4. **ب) چون `console` دیگر شیء نیست، بلکه یک مقدار اولیه (Primitive Value) است**: در خط `const console = 4711;`، شیء سراسری `console` با یک متغیر از نوع عدد جایگزین شده است، و چون اعداد متد `log()` ندارند، خطا رخ می‌دهد.

5. **ب) تعریف زیرکلاس‌ها**: `extends` برای تعریف زیرکلاس‌هایی که از یک سوپرکلاس ارث می‌برند، استفاده می‌شود.

6. **ج) `try`**: بلوک `try` برای تعریف کدی است که ممکن است خطا ایجاد کند، و سپس `catch` و `finally` آن خطا را مدیریت می‌کنند.

7. **ب) خیر، اما کلمه‌ای رزرو شده است**: `public` جزء کلمات کلیدی رزرو شده است، اما در حال حاضر هیچ تابعی به آن اختصاص داده نشده است.

8. اعلام (تعریف) متغیرها به منظور ذخیره‌سازی موقت داده‌ها در حافظه.

9. **`return`**: این کلمه کلیدی برای تعریف مقدار بازگشتی یک تابع استفاده می‌شود.

10. برای تعیین نوع (Type) یک متغیر یا عبارت از نظر مفسر جاوااسکریپت به کار می‌رود.

---
